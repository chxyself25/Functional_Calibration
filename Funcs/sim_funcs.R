# generate X by xi
X_v <- function(tmat, xi_z) {
  # different variables share common eigen functions
  psi_1 <- psi(tmat, k = 1)
  psi_2 <- psi(tmat, k = 2)
  psi_3 <- psi(tmat, k = 3)
  n <- nrow(xi_z)
  m <- ncol(tmat)
  mu <- mean_fun(tmat)
  if (n != nrow(tmat)) {
    cat("The xi and t do not match!\n")
  }
  res <- mu + sweep(psi_1, 1, xi_z[,1], "*") + sweep(psi_2, 1, xi_z[,2], "*") + sweep(psi_3, 1, xi_z[,3], "*")
  c(t(res))
}

# function for simulate datasets: dx X and dz Z, using structure 1
sim_data1 <- function(n, m, dx, dz, cor.pcs, sd.pcs, sd.e, beta) {
  # xi covariance matrix
  XX <- matrix(0, ncol = 3*dx, nrow = 3*dx)
  for (i in 1:(3*dx-1)) {
    vars <- floor((i-1)/3) + 1
    pcs <- (i-1) %% 3 + 1
    rep.row <- rep(0, 3-pcs)
    if (vars < dx) {
      rep.row <- append(c(sapply((vars+1):dx, function(x) {c(0, 0, ((cor.pcs[pcs])^(x-vars))*(sd.pcs[pcs]^2))})),
                        rep.row)
      # rep.row <- append(c(sapply((vars+1):10, function(x) {c(0, 0, ((cor.pcs[pcs])^(1))*(sd.pcs[pcs]^2))})), 
      #                   rep.row)
    }
    XX[i, (i+1):(3*dx)] <- rep.row
  }
  XX <- XX + t(XX)
  diag(XX) <- rep(sd.pcs^2, dx)
  # covariance between Z: assume they are independent, not relevant to our problem
  ZZ <- diag(1, nrow = dz)
  # final covariance matrix for generating random variables
  V <- matrix(0, ncol = 3*dx+dz, nrow = 3*dx+dz)
  V[1:(3*dx), 1:(3*dx)] <- XX
  V[(3*dx+1):(3*dx+dz), (3*dx+1):(3*dx+dz)] <- ZZ
  # generate random variables
  xi_z <- mvrnorm(n, mu = rep(0, 3*dx+dz), Sigma = V)
  # generate t(response) observations
  t_obs <- t(sapply(1:n, function(x) {sort(runif(m, min = 0, max = 10))}))
  # generate s(covariate) observations
  s_obs <- list()
  for (v in 1:dx) {
    s_obs[[v]] <- t(sapply(1:n, function(x) {sort(runif(m, min = 0, max = 10))}))
  }
  # true X matrix is on T domain for all vairables, 3000x10
  X_t <- sapply(1:dx, function(x) {X_v(t_obs, xi_z[, (3*(x-1)+1):(3*x)])})
  # true X matrix on S domain for all variables, 3000x10
  X_s <- sapply(1:dx, function(x) {X_v(s_obs[[x]], xi_z[, (3*(x-1)+1):(3*x)])})
  # observed W on S domain for all variables, measurement error is iid with mean zero and variance 0.25sde for all varaibles
  W_s <- X_s + sapply(1:dx, function(x) {rnorm(m*n, mean = 0, sd = sd.e)})
  Z_t <- apply(xi_z[, (3*dx+1):(3*dx+dz)], 2, function(x) {rep(x, each = m)}) # it's called Z_t, but time-invariant variables
  # observed Y: generated by true underlying X_t and Z_t
  # error terms 
  e <- apply(t_obs, 1, function(tt) {
    mvrnorm(n=1, mu = rep(0,m), Sigma = evar_fun(tt))
  })
  Y_t <- cbind(X_t, Z_t)%*%beta + c(e)
  return(list(Xt = X_t, Ws = W_s, Z = Z_t, Y = Y_t, s = s_obs, t = t_obs, V = V))
}

# asychronous data simulation, 10 X and 10 Z: using presentation by Multivariate Karhunenâ€“LoÃ¨ve Theorem
sim_data2 <- function(n, m, dx, dz, sd.pcs, sd.e, beta, basis.method = "split") {
  K <- length(sd.pcs)
  # generate t(response) observations
  t_obs <- t(sapply(1:n, function(x) {sort(runif(m, min = 0, max = 10))}))
  # generate s(covariate) observations
  s_obs <- list()
  for (v in 1:dx) {
    s_obs[[v]] <- t(sapply(1:n, function(x) {sort(runif(m, min = 0, max = 10))}))
  }
  # generate principle component scores
  V <- matrix(0, ncol = K+dz, nrow= K+dz)
  V[1:K, 1:K] <- diag(sd.pcs^2)
  V[(K+1):(K+dz), (K+1):(K+dz)] <- diag(1, nrow = dz)
  xi_z <- mvrnorm(n, mu = rep(0, K+dz), Sigma = V)
  # eigenfunctions construction
  # fourier basis functions
  if (basis.method == "split") {
    f.basis <- create.fourier.basis(rangeval = c(0, 10*dx), nbasis = ifelse(K%%2 == 0, K+1, K))
  } else {
    f.basis <- create.fourier.basis(rangeval = c(0, 10), nbasis = ifelse(K%%2 == 0, K+1, K))
  }
  # observed X: on s domain and t domain
  X_s <- NULL
  X_t <- NULL
  for (v in 1:dx) {
    meanvt <- mean_fun(t_obs)
    meanvs <- mean_fun(s_obs[[v]])
    # random sign: -1 or 1
    #signv <- sample(c(-1, 1), size = 1, prob = c(0.5, 0.5))
    if (basis.method == "split") {
      X_s <- cbind(X_s, unlist(lapply(1:n, function(x) {
        meanvs[x,] + eval.basis(s_obs[[v]][x,]+(v-1)*10, f.basis)[,1:K] %*% xi_z[x, 1:K]})))
      X_t <- cbind(X_t, unlist(lapply(1:n, function(x) {
        meanvt[x,] + eval.basis(t_obs[x,]+(v-1)*10, f.basis)[,1:K] %*% xi_z[x, 1:K]})))
    } else {
      X_s <- cbind(X_s, unlist(lapply(1:n, function(x) {
        meanvs[x,] + eval.basis(s_obs[[v]][x,], f.basis)[,1:K] %*% VD[[v]] %*% xi_z[x, 1:K]
      })))
      X_t <- cbind(X_t, unlist(lapply(1:n, function(x) {
        meanvt[x,] + eval.basis(t_obs[x,], f.basis)[,1:K] %*% VD[[v]] %*% xi_z[x, 1:K]
      })))
    }
  }
  # observed W on s domain, adding measurement error
  W_s <- X_s + sapply(1:dx, function(x) {rnorm(m*n, mean = 0, sd = sd.e)})
  # it's called Z_t, but time-invariant variables
  Z_t <- apply(xi_z[, (K+1):(K+dz)], 2, function(x) {rep(x, each = 5)})
  # observed Y at time t
  # error terms 
  e <- apply(t_obs, 1, function(tt) {
    mvrnorm(n=1, mu = rep(0,m), Sigma = evar_fun(tt))
  })
  Y_t <- cbind(X_t, Z_t)%*%beta + c(e)
  return(list(Xt = X_t, Ws = W_s, Z = Z_t, Y = Y_t, s = s_obs, t = t_obs, V = V))
}


# function for simulate datasets, only X variable, used for single covariates case, not completed for multiple case
sim_datax <- function(n, m, cor.pcs=NULL, sd.pcs, sd.e, dx=1, beta, method = "fix") {
  if (dx == 1) {
    XX <- diag(sd.pcs^2)
  } else {
    # xi covariance matrix
    XX <- matrix(0, ncol = 3*dx, nrow = 3*dx)
    for (i in 1:(3*dx-1)) {
      vars <- floor((i-1)/3) + 1
      pcs <- (i-1) %% 3 + 1
      rep.row <- rep(0, 3-pcs)
      if (vars < dx) {
        rep.row <- append(c(sapply((vars+1):dx, function(x) {c(0, 0, (cor.pcs[pcs])^(x-vars)*sd.pcs[pcs]^2)})), rep.row)
      }
      XX[i, (i+1):(3*dx)] <- rep.row
    }
    XX <- XX + t(XX)
    diag(XX) <- rep(sd.pcs^2, dx)
  }
  # generate random variables
  xis <- mvrnorm(n, mu = rep(0, 3*dx), Sigma = XX)
  # generate t(response) observations
  t_obs <- t(sapply(1:n, function(x) {sort(runif(m, min = 0, max = 10))}))
  # generate s(covariate) observations
  s_obs <- list()
  for (v in 1:dx) {
    s_obs[[v]] <- t(sapply(1:n, function(x) {sort(runif(m, min = 0, max = 10))}))
  }
  SigmaX <- NULL
  if (method == "basis") {
    f.basis <- create.fourier.basis(rangeval = c(0,10), nbasis = 3)
    phit <- lapply(1:n, function(x) {eval.basis(t_obs[x,], f.basis)})
    X_t <- matrix(0, ncol = dx, nrow = n*m)
    X_s <- matrix(0, ncol = dx, nrow = n*m)
    for (v in 1:dx) {
      xisv <- lapply(1:n, function(x) {xis[x, (3*(v-1)+1):(3*v)]})
      X_t[,v] <- c(t(mean_fun(t_obs))) + c(mapply(function(phi, xi) {
        phi %*% xi
      }, phit, xisv))
      phisv <- lapply(1:n, function(x) {eval.basis(s_obs[[v]][x,], f.basis)})
      X_s[,v] <- c(t(mean_fun(s_obs[[v]]))) + c(mapply(function(phi, xi) {
        phi %*% xi
      }, phisv, xisv))
    }
    tt <- seq(0, 10, by = 0.01)
    if (dx != 1) {
      SigmaX <- getSigmaX(xeigenfuns = eval.basis(tt, f.basis), xeigenv = sd.pcs^2,
                          xxeigenv = XX, xzeigenv = NULL, 
                          dx = dx, dz = NULL, t = tt)
    }
  } else {
    # true X matrix is on T domain for all vairables, 3000x10
    X_t <- sapply(1:dx, function(x) {X_v(t_obs, xis[, (3*(x-1)+1):(3*x)])})
    # true X matrix on S domain for all variables, 3000x10
    X_s <- sapply(1:dx, function(x) {X_v(s_obs[[x]], xis[, (3*(x-1)+1):(3*x)])})
    # sigma matrix
    tt <- seq(0, 10, by = 0.01)
    if (dx != 1) {
      SigmaX <- getSigmaX(xeigenfuns = cbind(psi(tt, 1), psi(tt, 2), psi(tt, 3)), xeigenv = sd.pcs^2,
                          xxeigenv = XX, xzeigenv = NULL, 
                          dx = dx, dz = NULL, t = tt)
    }
  }
  # observed W on S domain for all variables, measurement error is iid with mean zero and sd.e for all varaibles
  W_s <- X_s + sapply(1:dx, function(x) {rnorm(m*n, mean = 0, sd = sd.e)})
  # observed y response
  # error terms 
  e <- apply(t_obs, 1, function(tt) {
    mvrnorm(n=1, mu = rep(0,m), Sigma = evar_fun(tt))
  })
  #Y <- cbind(1, X_t)%*%b + rnorm(n*m, mean = 0, sd = 1)
  Y <- cbind(1, X_t)%*%beta + c(e)
  return(list(Xt = X_t, Xs = X_s, Ws = W_s, s = s_obs, t = t_obs, V = XX, Y = Y))
}

## function for calculating integral, check if the eigen function satisfies conditions
func_prod <- function(phi1, phi2 = NULL, tt) {
  m <- ncol(phi1)
  if (is.null(phi2)) {
    phi2 <- phi1
  }
  res <- 0
  for (i in 1:m) {
    res <- res + trapzRcpp(X = tt, Y = (phi1[,i,drop = FALSE])*(phi2[,i,drop = FALSE]))
  }
  return(res)
}

## function for simulating time-dependent coefficient case: dx = 1 only
sim_dataxt1 <- function(n, m, sd.pcs, sd.e, uni.f = 1) {
  XX <- diag(sd.pcs^2)
  # generate random variables
  xis <- mvrnorm(n, mu = rep(0, 3), Sigma = XX)
  # generate t(response) observations
  t_obs <- t(sapply(1:n, function(x) {sort(runif(m, min = 0, max = 10))}))
  #t_obs <- matrix(rep(sort(runif(m, min = 0, max = 10)), n), byrow = TRUE, ncol = m)
  #tuni <- runif(uni.f*m, min = 0, max = 10)
  #t_obs <- t(sapply(1:n, function(x) {sort(sample(tuni, m, replace = FALSE))}))
  # generate s(covariate) observations
  s_obs <- list()
  s_obs[[1]] <- t(sapply(1:n, function(x) {sort(runif(m, min = 0, max = 10))}))
  
  # true X matrix is on T domain for all vairables, 3000x10
  X_t <- as.matrix(X_v(t_obs, xis))
  # true X matrix on S domain for all variables, 3000x10
  X_s <- as.matrix(X_v(s_obs[[1]], xis))
  # observed W on S domain for all variables, measurement error is iid with mean zero and sd.e for all varaibles
  W_s <- X_s + as.matrix(rnorm(m*n, mean = 0, sd = sd.e))
  # observed y response
  # error terms 
  e <- apply(t_obs, 1, function(tt) {
    mvrnorm(n=1, mu = rep(0,m), Sigma = evar_fun(tt))
  })
  Y <- beta_fun(c(t(t_obs)), intercept = TRUE) + X_t * beta_fun(c(t(t_obs)), intercept = FALSE) + c(e)
  return(list(Xt = X_t, Xs = X_s, Ws = W_s, s = s_obs, t = t_obs, V = XX, Y = Y))
}


# functions for caculating theoretical SigmaX, covariance of covariates, K = 3(fixed)
# xeigenfuns is a list of eigenfunctions of X's, xeigenv is a list of eigenvalues of X's
# xxeigenv is the cross-covariance matrix, xzeigenv is XZ covariance matrix
getSigmaX <- function(xeigenfuns, xeigenv, xxeigenv, xzeigenv=NULL, dx, dz=NULL, t) {
  kgrids <- expand.grid(1:3, 1:3)
  matxx <- matrix(0, ncol = dx, nrow = dx)
  for (j in 1:(dx-1)) {
    for (l in (j+1):dx) {
      omegajl <- xxeigenv[(3*(j-1)+1):(j*3), (3*(l-1)+1):(l*3)]
      temp <- sapply(1:9, function(x) {
        omegajl[kgrids[x,1], kgrids[x,2]]*xeigenfuns[,kgrids[x,1]]*xeigenfuns[,kgrids[x,2]]
      })
      matxx[j, l] <- trapzRcpp(X = t, Y = apply(temp, 1, sum))
    }
  }
  matxx <- matxx + t(matxx)
  diag(matxx) <- rep(trapzRcpp(X = t, Y = xeigenfuns^2 %*% xeigenv), dx)
  if (!is.null(dz)) {
    matxz <- matrix(0, nrow = dx, ncol = dz)
    for (j in 1:dx) {
      omegajl <- xzeigenv[(3*(j-1)+1):(j*3),]
      temp <- sapply(1:dz, function(x) {xeigenfuns %*% omegajl[,x]})
      matxz[j, ] <- apply(temp, 2, function(y) {trapzRcpp(X = t, Y = y)})
    }
    return(rbind(cbind(matxx, matxz), cbind(t(matxz), diag(1, dz))))
  } else {
    return(matxx) 
  }
}
